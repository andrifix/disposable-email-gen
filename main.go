package main

import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"slices"
	"strconv"
	"strings"
	"time"

	. "github.com/dave/jennifer/jen"
)

const (
	domainsURL          = "https://disposable.github.io/disposable-email-domains/domains.json"
	userAgent           = "DisposableEmailsGen/1.0"
	defaultFilename     = "domains.go"
	defaultPackageName  = "main"
	fetchInterval       = 24 * time.Hour
	commentPrefixHash   = "// hash: "
	commentPrefixRunAt  = "// run at: "
	generatedCodeHeader = "Code generated by DisposableEmailsGen. DO NOT EDIT."
)

var errNotModified = errors.New("not modified")

type fileInfo struct {
	ETag      string
	LastFetch time.Time
}

func parseFileInfo(fileName string) (info fileInfo, err error) {
	content, err := os.ReadFile(fileName)
	if err != nil {
		if errors.Is(err, os.ErrNotExist) {
			return info, nil
		}
		return info, fmt.Errorf("failed to read file %s: %w", fileName, err)
	}

	if len(content) == 0 {
		return info, nil
	}

	lines := strings.Split(string(content), "\n")
	var etagFound, runAtFound bool

	for _, line := range lines {
		if strings.HasPrefix(line, commentPrefixHash) {
			info.ETag = strings.TrimSpace(strings.TrimPrefix(line, commentPrefixHash))
			etagFound = true
		} else if strings.HasPrefix(line, commentPrefixRunAt) {
			timestampStr := strings.TrimSpace(strings.TrimPrefix(line, commentPrefixRunAt))
			timestamp, err := strconv.ParseInt(timestampStr, 10, 64)
			if err != nil {
				fmt.Fprintf(os.Stderr, "Warning: Could not parse timestamp '%s': %v\n", timestampStr, err)
				continue
			}

			info.LastFetch = time.Unix(timestamp, 0)
			runAtFound = true
		}
		if etagFound && runAtFound {
			break
		}
	}

	if !etagFound {
		fmt.Fprintf(os.Stderr, "Warning: Could not find ETag in %s\n", fileName)
	}
	if !runAtFound {
		fmt.Fprintf(os.Stderr, "Warning: Could not find last fetch time in %s\n", fileName)
	}

	return info, nil
}

func fetchDomains(url string, currentETag string) (domains []string, newETag string, err error) {
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, "", fmt.Errorf("failed to create request: %w", err)
	}
	req.Header.Set("User-Agent", userAgent)
	req.Header.Set("Accept", "application/json")
	if currentETag != "" {
		req.Header.Set("If-None-Match", currentETag)
	}

	transport := &http.Transport{
		Proxy:                 http.ProxyFromEnvironment,
		ForceAttemptHTTP2:     true,
		MaxIdleConns:          10,
		IdleConnTimeout:       90 * time.Second,
		TLSHandshakeTimeout:   10 * time.Second,
		ExpectContinueTimeout: 1 * time.Second,
	}
	client := &http.Client{
		Transport: transport,
		Timeout:   60 * time.Second,
	}

	response, err := client.Do(req)
	if err != nil {
		return nil, currentETag, fmt.Errorf("http request failed: %w", err)
	}
	defer response.Body.Close()

	newETag = strings.Trim(response.Header.Get("ETag"), `" `)

	switch response.StatusCode {
	case http.StatusOK:
		body, err := io.ReadAll(response.Body)
		if err != nil {
			return nil, newETag, fmt.Errorf("failed to read response body: %w", err)
		}

		var blackList []string
		err = json.Unmarshal(body, &blackList)
		if err != nil {
			return nil, newETag, fmt.Errorf("failed to unmarshal json: %w", err)
		}
		return blackList, newETag, nil

	case http.StatusNotModified:
		fmt.Println("Domain list is already up-to-date.")
		return nil, currentETag, errNotModified

	default:
		bodyBytes, _ := io.ReadAll(response.Body)
		return nil, currentETag, fmt.Errorf("http request failed with status code %d (%s): %s", response.StatusCode, response.Status, string(bodyBytes))
	}
}

func generateCode(packageName string, domains []string, etag string) (*File, error) {
	if packageName == "" {
		return nil, errors.New("package name cannot be empty")
	}
	slices.Sort(domains)

	domainLiterals := make([]Code, len(domains))
	for i, domain := range domains {
		domainLiterals[i] = Lit(domain)
	}

	f := NewFile(packageName)
	f.HeaderComment(generatedCodeHeader)
	f.Commentf(commentPrefixHash + etag)
	f.Commentf(commentPrefixRunAt + strconv.FormatInt(time.Now().Unix(), 10)).Line()

	f.Var().Id("DisposableDomains").Op("=").Index().String().Values(domainLiterals...)

	return f, nil
}

func run(outputFilename, packageName string) error {
	info, err := parseFileInfo(outputFilename)
	if err != nil {
		return fmt.Errorf("error getting info from %s: %w", outputFilename, err)
	}

	if !info.LastFetch.IsZero() && time.Since(info.LastFetch) < fetchInterval {
		fmt.Printf("Skipping fetch: Last fetch was less than %s ago.\n", fetchInterval)
		return nil
	}

	newDomains, newETag, err := fetchDomains(domainsURL, info.ETag)
	if err != nil {
		if errors.Is(err, errNotModified) {
			return nil
		}
		return fmt.Errorf("failed to fetch domains: %w", err)
	}

	if newETag == "" && info.ETag != "" {
		fmt.Fprintf(os.Stderr, "Warning: Server did not provide an ETag for the update.\n")
	}

	f, err := generateCode(packageName, newDomains, newETag)
	if err != nil {
		return fmt.Errorf("failed to generate code: %w", err)
	}

	outputDir := filepath.Dir(outputFilename)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory %s: %w", outputDir, err)
	}

	err = f.Save(outputFilename)
	if err != nil {
		return fmt.Errorf("failed to write output file %s: %w", outputFilename, err)
	}

	fmt.Printf("Successfully updated %s with %d domains.\n", outputFilename, len(newDomains))
	return nil
}

func main() {
	outputFilename := defaultFilename
	packageName := defaultPackageName

	if len(os.Args) > 1 {
		outputFilename = os.Args[1]
		if !strings.HasSuffix(strings.ToLower(outputFilename), ".go") {
			outputFilename = filepath.Join(outputFilename, defaultFilename)
		}
	}
	if len(os.Args) > 2 {
		packageName = os.Args[2]
		if packageName == "" {
			packageName = defaultPackageName
		}
	}

	if err := run(outputFilename, packageName); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}
